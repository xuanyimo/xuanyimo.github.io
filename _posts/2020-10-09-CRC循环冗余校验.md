---
layout: post
title: "CRC循环冗余检验算法"
date: 2020-10-09 15:00:00 +0800
description: CRC 算法说明及实现
tag: [CRC]
categaries: [others]
---

* Kramdown table of contents
{:toc .toc}


# 奇偶校验

所谓通讯过程的校验是指在通讯数据后加上一些附加信息，通过这些附加信息来判断接收到的数据是否和发送出的数据相同。
所谓奇偶校验就是在发送的每一个字节后都加上一位，使得每个字节中1的个数为奇数个或偶数个。比如我们要发送的字节是0x1a，二进制表示为0001 1010。

采用奇校验，则在数据后补上个0，数据变为0001 1010 0，数据中1的个数为奇数个（3个）

采用偶校验，则在数据后补上个1，数据变为0001 1010 1，数据中1的个数为偶数个（4个）

接收方通过计算数据中1个数是否满足奇偶性来确定数据是否有错。

奇偶校验的缺点也很明显，首先，它对错误的检测概率大约只有50%。也就是只有一半的错误它能够检测出来。另外，每传输一个字节都要附加一位校验位，对传输效率的影响很大。因此，在高速数据通讯中很少采用奇偶校验。奇偶校验优点也很明显，它很简单，因此可以用硬件来实现，这样可以减少软件的负担。因此，奇偶校验也被广泛的应用着。

奇偶校验就先介绍到这来，之所以从奇偶校验说起，是因为这种校验方式最简单，而且后面将会知道奇偶校验其实就是CRC 校验的一种(CRC-1)。


# 累加和校验

另一种常见的校验方式是累加和校验。所谓累加和校验实现方式有很多种，最常用的一种是在一次通讯数据包的最后加入一个字节的校验数据。这个字节内容为前面数据包中全部数据的忽略进位的按字节累加和。比如下面的例子：

我们要传输的信息为： 6、23、4

加上校验和后的数据包：6、23、4、33

这里 33 为前三个字节的校验和。接收方收到全部数据后对前三个数据进行同样的累加计算，如果累加和与最后一个字节相同的话就认为传输的数据没有错误。

累加和校验由于实现起来非常简单，也被广泛的采用。但是这种校验方式的检错能力也比较一般，对于单字节的校验和大概有1/256 的概率将原本是错误的通讯数据误判为正确数据。之所以这里介绍这种校验，是因为CRC校验在传输数据的形式上与累加和校验是相同的，都可以表示为：通讯数据 校验字节（也可能是多个字节）

# CRC 算法

CRC 算法的基本思想是将传输的数据当做一个位数很长的数。将这个数除以另一个数。得到的余数作为校验数据附加到原数据后面。还以上面例子中的数据为例：

6、23、2 可以看做一个2进制数： 00000110 00010111 00000010

假如被除数选9，二进制表示为：1001

则除法运算可以表示为：

<img src="{{ site.baseurl }}/assets/images/others/crc0.png" style="width: 100%">

可以看到，最后的余数为1。如果我们将这个余数作为校验和的话，传输的数据则是：6、23、2、1

CRC 算法和这个过程有点类似，不过采用的不是上面例子中的通常的这种除法。在CRC算法中，将二进制数据流作为多项式的系数，然后进行的是多项式的乘除法。还是举个例子吧。

比如说我们有两个二进制数，分别为：1101 和1011。

1101 与如下的多项式相联系：1x3+1x2+0x1+1x0=x3+x2+x0

1011与如下的多项式相联系：1x3+0x2+1x1+1x0=x3+x1+x0

两个多项式的乘法：(x3+x2+x0)(x3+x1+x0)=x6+x5+x4+x3+x3+x3+x2+x1+x0

得到结果后，合并同类项时采用模2运算。也就是说乘除法采用正常的多项式乘除法，而加减法都采用模2运算。所谓模2运算就是结果除以2后取余数。比如3 mod 2 = 1。因此，上面最终得到的多项式为：x6+x5+x4+x3+x2+x1+x0，对应的二进制数:111111

加减法采用模2运算后其实就成了一种运算了，就是我们通常所说的异或运算：

| 0+0-0 | 0-0=0 |
| 0+1=0 | 1-0=1 |
| 1+0=1 | 0-1=1 |
| 1+1=0 | 1-1=0 |

除法运算与上面给出的乘法概念类似，还是遇到加减的地方都用异或运算来代替。下面是一个例子：

要传输的数据为：1101011011

除数设为：10011

在计算前先将原始数据后面填上4个0：11010110110000，之所以要补0，后面再做解释。

<img src="{{ site.baseurl }}/assets/images/others/crc1.png" style="width: 100%">

从这个例子可以看出，采用了模2的加减法后，不需要考虑借位的问题，所以除法变简单了。最后得到的余数就是CRC 校验字。为了进行CRC运算，也就是这种特殊的除法运算，必须要指定个被除数，在CRC算法中，这个被除数有一个专有名称叫做“生成多项式”。

最常用的几种生成多项式如下：

CRC8=X8+X5+X4+X0

CRC-CCITT=X16+X12+X5+X0

CRC16=X16+X15+X2+X0

CRC12=X12+X11+X3+X2+X0

CRC32=X32+X26+X23+X22+X16+X12+X11+X10+X8+X7+X5+X4+X2+X1+X0

有一点要特别注意，文献中提到的生成多项式经常会说到多项式的位宽（Width，简记为W），这个位宽不是多项式对应的二进制数的位数，而是位数减1。比如CRC8中用到的位宽为8的生成多项式，其实对应得二进制数有九位：100110001。另外一点，多项式表示和二进制表示都很繁琐，交流起来不方便，因此，文献中多用16进制简写法来表示，因为生成多项式的最高位肯定为1，最高位的位置由位宽可知，故在简记式中，将最高的1统一去掉了，如CRC32的生成多项式简记为04C11DB7实际上表示的是104C11DB7。当然，这样简记除了方便外，在编程计算时也有它的用处。

对于上面的例子，位宽为4（W=4），按照CRC算法的要求，计算前要在原始数据后填上W个0，也就是4个0。

位宽W=1的生成多项式(CRC1)有两种，分别是X1和X1+X0，读者可以自己证明10 对应的就是奇偶校验中的奇校验，而11对应则是偶校验。因此，写到这里我们知道了奇偶校验其实就是CRC校验的一种特例，这也是我要以奇偶校验作为开篇介绍的原因了。

# CRC算法的编程实现

假设我们的生成多项式为：100110001（简记为0x31），也就是CRC-8

则计算步骤如下：

（1）      将CRC寄存器（8-bits，比生成多项式少1bit）赋初值0

（2）      在待传输信息流后面加入8个0

（3）      While (数据未处理完)

（4）      Begin

（5）          If (CRC寄存器首位是1)

（6）              reg = reg XOR 0x31

（7）          CRC寄存器左移一位，读入一个新的数据于CRC寄存器的0 bit的位置。

（8）      End

（9）      CRC寄存器就是我们所要求的余数。

实际上，真正的CRC 计算通常与上面描述的还有些出入。这是因为这种最基本的CRC除法有个很明显的缺陷，就是数据流的开头添加一些0并不影响最后校验字的结果。这个问题很让人恼火啊，因此真正应用的CRC 算法基本都在原始的CRC算法的基础上做了些小的改动。

所谓的改动，也就是增加了两个概念，第一个是“余数初始值”，第二个是“结果异或值”。

所谓的“余数初始值”就是在计算CRC值的开始，给CRC寄存器一个初始值。“结果异或值”是在其余计算完成后将CRC寄存器的值在与这个值进行一下异或操作作为最后的校验值。

常见的三种CRC 标准用到个各个参数如下表。

|            | CCITT | CRC16 | CRC32 |
|校验和位宽W | 16 | 16 | 32 |
|生成多项式 | x16+x12+x5+1 | x16+x15+x2+1 | x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x1+1 |
|除数(多项式) | 0x1021 | 0x8005 | 0x04C11DB7 |
|余数初始值 | 0xFFFF | 0x0000 | 0xFFFFFFFF |
|结果异或值 | 0x0000 | 0x0000 | 0xFFFFFFFF |


加入这些变形后，常见的算法描述形式就成了这个样子了：

1.      设置CRC寄存器，并给其赋值为“余数初始值”。
2.      将数据的第一个8-bit字符与CRC寄存器进行异或，并把结果存入CRC寄存器。
3.      CRC寄存器向右移一位，MSB补零，移出并检查LSB。
4.      如果LSB为0，重复第三步；若LSB为1，CRC寄存器与0x31相异或。
5.      重复第3与第4步直到8次移位全部完成。此时一个8-bit数据处理完毕。
6.      重复第2至第5步直到所有数据全部处理完成。
7.      最终CRC寄存器的内容与“结果异或值”进行或非操作后即为CRC值。


示例性的C代码如下所示，因为效率很低，项目中如对计算时间有要求应该避免采用这样的代码。不过这个代码已经比网上常见的计算代码要好了，因为这个代码有一个crc的参数，可以将上次计算的crc结果传入函数中作为这次计算的初始值，这对大数据块的CRC计算是很有用的，不需要一次将所有数据读入内存，而是读一部分算一次，全读完后就计算完了。这对内存受限系统还是很有用的。

{% highlight c %}
#define POLY        0x1021
/**
 * Calculating CRC-16 in 'C'
 * @para addr, start of data
 * @para num, length of data
 * @para crc, incoming CRC
 */
uint16_t crc16(unsigned char *addr, int num, uint16_t crc)
{
    int i;
    for (; num > 0; num--)              /* Step through bytes in memory */
    {
        crc = crc ^ (*addr++ << 8);     /* Fetch byte from memory, XOR into CRC top byte*/
        for (i = 0; i < 8; i++)             /* Prepare to rotate 8 bits */
        {
            if (crc & 0x8000)            /* b15 is set... */
                crc = (crc << 1) ^ POLY;    /* rotate and XOR with polynomic */
            else                          /* b15 is clear... */
                crc <<= 1;                  /* just rotate */
        }                             /* Loop for 8 bits */
        crc &= 0xFFFF;                  /* Ensure CRC remains 16-bit value */
    }                               /* Loop until num=0 */
    return(crc);                    /* Return updated CRC */
}
{% endhighlight %}



{% highlight c %}
    unsigned char data1[] = {'1', '2', '3', '4', '5', '6', '7', '8', '9'};
    unsigned char data2[] = {'5', '6', '7', '8', '9'};
    unsigned short c1, c2;
    c1 = crc16(data1, 9, 0xffff);
    c2 = crc16(data1, 4, 0xffff);
    c2 = crc16(data2, 5, c2);
    printf("%04x\n", c1);
    printf("%04x\n", c2);
{% endhighlight %}
